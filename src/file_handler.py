from pathlib import Path
from datetime import datetime
import json

class FileHandler:
    def __init__(self, output_dir):
        self.output_dir = Path(output_dir)
        self.text_dir = self.output_dir / 'text'
        self.audio_dir = self.output_dir / 'audio'
        self._setup_directories()

    def _setup_directories(self):
        """Ensure all required directories exist"""
        self.text_dir.mkdir(parents=True, exist_ok=True)
        self.audio_dir.mkdir(parents=True, exist_ok=True)

    def save_qa_text(self, qa_pairs, filename=None):
        """Save Q&A pairs to a markdown file in a beautiful conversation format"""
        if filename is None:
            filename = f"conversation_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"
        else:
            # Ensure .md extension
            filename = filename.replace('.txt', '.md')
        
        file_path = self.text_dir / filename
        timestamp = datetime.now()
        
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                # Write header with metadata
                f.write(f"# Conversation Log\n\n")
                f.write(f"*Recorded on: {timestamp.strftime('%B %d, %Y at %I:%M:%S %p')}*\n\n")
                f.write("---\n\n")
                
                # Write each Q&A pair
                for i, qa_pair in enumerate(qa_pairs, 1):
                    lines = qa_pair.strip().split('\n')
                    if len(lines) >= 2:
                        question = lines[0][2:]  # Remove "Q: "
                        answer = lines[1][3:]    # Remove "A: "
                        
                        # Question section with emoji and formatting
                        f.write(f"## 💭 Question {i}\n\n")
                        f.write(f"```question\n{question}\n```\n\n")
                        
                        # Answer section with emoji and formatting
                        f.write(f"### 🤖 Answer\n\n")
                        
                        # Format answer text with proper markdown
                        formatted_answer = answer.replace('\n', '\n\n')  # Ensure proper paragraph breaks
                        
                        # If answer contains lists, format them properly
                        if any(line.strip().startswith(('-', '*', '1.')) for line in formatted_answer.split('\n')):
                            formatted_answer = '\n'.join(
                                f"{line}" if line.strip().startswith(('-', '*', '1.')) else line
                                for line in formatted_answer.split('\n')
                            )
                        
                        f.write(f"{formatted_answer}\n\n")
                        
                        # Add separator between Q&A pairs
                        if i < len(qa_pairs):
                            f.write("---\n\n")
                
                # Footer with audio file reference
                f.write("\n## 📝 Conversation Details\n\n")
                f.write("- Audio responses are available in the `audio` directory\n")
                f.write(f"- Conversation ID: `{filename.replace('.md', '')}`\n")
                f.write("\n---\n\n")
                f.write("*Generated by Jarvis Voice Assistant*")
            
            return filename
        except Exception as e:
            print(f"❌ Error saving Q&A file: {e}")
            return None

    def get_audio_path(self, filename):
        """Get the full path for an audio file"""
        return self.audio_dir / filename

    def save_conversation_metadata(self, original_audio, qa_pairs, audio_files, timestamp):
        """Save conversation metadata for future reference"""
        metadata = {
            "timestamp": timestamp,
            "original_audio": str(original_audio),
            "num_questions": len(qa_pairs),
            "audio_files": [str(f) for f in audio_files],
            "text_file": f"conversation_{timestamp}.md"  # Updated extension
        }
        
        metadata_file = self.text_dir / f"metadata_{timestamp}.json"
        try:
            with open(metadata_file, 'w', encoding='utf-8') as f:
                json.dump(metadata, f, indent=2)
        except Exception as e:
            print(f"❌ Error saving metadata: {e}")

    def list_conversations(self):
        """List all available conversations"""
        conversations = []
        for metadata_file in self.text_dir.glob("metadata_*.json"):
            try:
                with open(metadata_file, 'r', encoding='utf-8') as f:
                    metadata = json.load(f)
                    conversations.append(metadata)
            except Exception:
                continue
        return sorted(conversations, key=lambda x: x['timestamp'], reverse=True) 